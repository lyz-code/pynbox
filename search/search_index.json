{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pynbox aims to help you with the daily emptying of the inbox by: Prioritizing the elements by their type. Giving insights on the inbox status. Giving feedback on the inbox processing process. Making the insertion of new elements as effortless as possible. Installing \u00b6 pip install pynbox Quick overview \u00b6 Proposed workflow \u00b6 When you're on your desktop you can add elements directly with the command line , when you're on the go, use any text editor, such as Markor , and sync the file with Syncthing to your laptop, and then parse the file . To process the elements, you can daily use pynbox process . If you want to focus on a category, use pynbox process category . References \u00b6 As most open sourced programs, pynbox is standing on the shoulders of giants, namely: Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakeheaven Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer. Contributing \u00b6 For guidance on setting up a development environment, and how to make a contribution to pynbox , see Contributing to pynbox .","title":"pynbox"},{"location":"#installing","text":"pip install pynbox","title":"Installing"},{"location":"#quick-overview","text":"","title":"Quick overview"},{"location":"#proposed-workflow","text":"When you're on your desktop you can add elements directly with the command line , when you're on the go, use any text editor, such as Markor , and sync the file with Syncthing to your laptop, and then parse the file . To process the elements, you can daily use pynbox process . If you want to focus on a category, use pynbox process category .","title":"Proposed workflow"},{"location":"#references","text":"As most open sourced programs, pynbox is standing on the shoulders of giants, namely: Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakeheaven Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer.","title":"References"},{"location":"#contributing","text":"For guidance on setting up a development environment, and how to make a contribution to pynbox , see Contributing to pynbox .","title":"Contributing"},{"location":"configuration/","text":"The first time you use pynbox , it will create the default configuration in ~/.local/share/pynbox or the path of the -c command line argument. database_url \u00b6 pynbox uses repository_orm to persist the elements. By default, it uses the TinyDB backend, if you encounter performance issues, move to SQLite , and then to MySQL. Refer to the docs of repository_orm to do so. max_time \u00b6 You should not spend too much time processing your inbox, the idea is that if it will take you more than 2 minutes to process an element, it's better to create a task to address it. max_time defines the maximum number of seconds to process an element. A warning will be shown if it takes you longer. types \u00b6 It's where you define the element categories, their regular expressions and their priority. For example: types : task : regexp : t\\. priority : 4 idea : regexp : i\\. If the priority is not defined, it's assumed to be 3 . The regular expression needs to be a non capturing one If you use parenthesis use (?:<regular expression>) instead of (<regular expression>) .","title":"Configuration"},{"location":"configuration/#database_url","text":"pynbox uses repository_orm to persist the elements. By default, it uses the TinyDB backend, if you encounter performance issues, move to SQLite , and then to MySQL. Refer to the docs of repository_orm to do so.","title":"database_url"},{"location":"configuration/#max_time","text":"You should not spend too much time processing your inbox, the idea is that if it will take you more than 2 minutes to process an element, it's better to create a task to address it. max_time defines the maximum number of seconds to process an element. A warning will be shown if it takes you longer.","title":"max_time"},{"location":"configuration/#types","text":"It's where you define the element categories, their regular expressions and their priority. For example: types : task : regexp : t\\. priority : 4 idea : regexp : i\\. If the priority is not defined, it's assumed to be 3 . The regular expression needs to be a non capturing one If you use parenthesis use (?:<regular expression>) instead of (<regular expression>) .","title":"types"},{"location":"contributing/","text":"So you've started using pynbox and want to show your gratitude to the project, depending on your programming skills there are different ways to do so. I don't know how to program \u00b6 There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it. I know how to program in Python \u00b6 If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Issues \u00b6 Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import pynbox.version; print(pynbox.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install pynbox or know it's not relevant to your question or feature request. Pull Requests \u00b6 pynbox is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. Development facilities \u00b6 To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/pynbox.git cd pynbox Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install pynbox, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: pynbox uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to pynbox !","title":"Contributing"},{"location":"contributing/#i-dont-know-how-to-program","text":"There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it.","title":"I don't know how to program"},{"location":"contributing/#i-know-how-to-program-in-python","text":"If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you.","title":"I know how to program in Python"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import pynbox.version; print(pynbox.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install pynbox or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"pynbox is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.","title":"Pull Requests"},{"location":"contributing/#development-facilities","text":"To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/pynbox.git cd pynbox Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install pynbox, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: pynbox uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to pynbox !","title":"Development facilities"},{"location":"creating_new_elements/","text":"To add new elements into pynbox, you need to use the defined markup language either through the command line or through a file . Pynbox markup language \u00b6 It's designed to use the minimum number of friendly keystrokes both for a mobile and a laptop. The format of each element is: {{ type_identifier }} {{ description }} {{ body }} Where: type_identifier : Is a case insensitive string of the fewest letters as possible, that identifies the type of the element. It can be for example t. for a task, or i. for an idea. The identifiers are defined in the configuration file . description : A short sentence that defines the element. body : An optional group of paragraphs with more information of the element. For example: T. buy groceries * milk * tofu i. to have an inbox management tool would be awesome! Command line \u00b6 You can use the add subcommand to put new items into the inbox. pynbox add t. buy milk Parse a file \u00b6 If you need to add elements with a body, more than one element, or want to import them from other device, using a file might be easier. Write the elements one after the other in the file and then use the parse command. pynbox parse file.txt","title":"Creating new elements"},{"location":"creating_new_elements/#pynbox-markup-language","text":"It's designed to use the minimum number of friendly keystrokes both for a mobile and a laptop. The format of each element is: {{ type_identifier }} {{ description }} {{ body }} Where: type_identifier : Is a case insensitive string of the fewest letters as possible, that identifies the type of the element. It can be for example t. for a task, or i. for an idea. The identifiers are defined in the configuration file . description : A short sentence that defines the element. body : An optional group of paragraphs with more information of the element. For example: T. buy groceries * milk * tofu i. to have an inbox management tool would be awesome!","title":"Pynbox markup language"},{"location":"creating_new_elements/#command-line","text":"You can use the add subcommand to put new items into the inbox. pynbox add t. buy milk","title":"Command line"},{"location":"creating_new_elements/#parse-a-file","text":"If you need to add elements with a body, more than one element, or want to import them from other device, using a file might be easier. Write the elements one after the other in the file and then use the parse command. pynbox parse file.txt","title":"Parse a file"},{"location":"reference/","text":"pynbox special \u00b6 Task management inbox tool. config \u00b6 Define the configuration of the main program. Config ( GoodConf ) pydantic-model \u00b6 Configure the frontend. Source code in pynbox/config.py class Config ( GoodConf ): # type: ignore \"\"\"Configure the frontend.\"\"\" # URL specifying the connection to the database. For example: # * tinydb: tinydb:////home/user/database.tinydb # * sqlite: sqlite:////home/user/mydb.sqlite # * mysql: mysql://scott:tiger@localhost/mydatabase database_url : str = \"tinydb://~/.local/share/pynbox/database.json\" # Maximum time to process an element. A warning will be shown if it takes you # longer. max_time : int = 120 # List of element types. Each element can define: # * regexp: regular expression that identifies it # * priority: type priority, by default 3. types : List [ ElementType ] = [] log_level : LogLevel = LogLevel . INFO class Config : \"\"\"Define the default files to check.\"\"\" default_files = [ os . path . expanduser ( \"~/.local/share/pynbox/config.yaml\" ), \"config.yaml\" , ] Config \u00b6 Define the default files to check. Source code in pynbox/config.py class Config : \"\"\"Define the default files to check.\"\"\" default_files = [ os . path . expanduser ( \"~/.local/share/pynbox/config.yaml\" ), \"config.yaml\" , ] LogLevel ( str , Enum ) \u00b6 Define the possible log levels. Source code in pynbox/config.py class LogLevel ( str , Enum ): \"\"\"Define the possible log levels.\"\"\" DEBUG = \"debug\" INFO = \"info\" WARNING = \"warning\" ERROR = \"error\" entrypoints special \u00b6 Define the different ways to expose the program functionality. Functions load_logger: Configure the Logging logger. get_repo ( config ) \u00b6 Configure the repository. Source code in pynbox/entrypoints/__init__.py def get_repo ( config : \"Config\" ) -> Repository : \"\"\"Configure the repository.\"\"\" log . debug ( \"Initializing repository\" ) repo = load_repository ( database_url = config . database_url , search_exception = False ) return repo load_config ( config_path ) \u00b6 Load the configuration from the file. Source code in pynbox/entrypoints/__init__.py def load_config ( config_path : str ) -> Config : \"\"\"Load the configuration from the file.\"\"\" log . debug ( f \"Loading the configuration from file { config_path } \" ) config = Config () try : config . load ( os . path . expanduser ( config_path )) except ParserError as error : log . error ( f \"Configuration Error: { str ( error ) } \" ) sys . exit ( 1 ) return config load_logger ( verbose = False ) \u00b6 Configure the Logging logger. Parameters: Name Type Description Default verbose bool Set the logging level to Debug. False Source code in pynbox/entrypoints/__init__.py def load_logger ( verbose : bool = False ) -> None : # pragma no cover \"\"\"Configure the Logging logger. Args: verbose: Set the logging level to Debug. \"\"\" logging . addLevelName ( logging . INFO , \"[ \\033 [36m+ \\033 [0m]\" ) logging . addLevelName ( logging . ERROR , \"[ \\033 [31m+ \\033 [0m]\" ) logging . addLevelName ( logging . DEBUG , \"[ \\033 [32m+ \\033 [0m]\" ) logging . addLevelName ( logging . WARNING , \"[ \\033 [33m+ \\033 [0m]\" ) if verbose : logging . basicConfig ( stream = sys . stderr , level = logging . DEBUG , format = \" %(levelname)s %(message)s \" ) else : logging . basicConfig ( stream = sys . stderr , level = logging . INFO , format = \" %(levelname)s %(message)s \" ) cli \u00b6 Define the command line interface. exceptions \u00b6 Define the program exceptions. ParseError ( Exception ) \u00b6 Gather the exceptions when parsing markup text. Source code in pynbox/exceptions.py class ParseError ( Exception ): \"\"\"Gather the exceptions when parsing markup text.\"\"\" model \u00b6 Define the program models. Element ( Entity ) pydantic-model \u00b6 Define the element model. Source code in pynbox/model.py class Element ( Entity ): \"\"\"Define the element model.\"\"\" type_ : str description : str body : Optional [ str ] = None priority : int = 3 skips : int = 0 state : ElementState = ElementState . OPEN created : datetime = Field ( default_factory = datetime . now ) closed : Optional [ datetime ] = None def close ( self ) -> None : \"\"\"Close an element.\"\"\" self . state = ElementState . CLOSED self . closed = datetime . now () def delete ( self ) -> None : \"\"\"Delete an element.\"\"\" self . state = ElementState . DELETED self . closed = datetime . now () def skip ( self ) -> None : \"\"\"Skip an element.\"\"\" self . skips += 1 close ( self ) \u00b6 Close an element. Source code in pynbox/model.py def close ( self ) -> None : \"\"\"Close an element.\"\"\" self . state = ElementState . CLOSED self . closed = datetime . now () delete ( self ) \u00b6 Delete an element. Source code in pynbox/model.py def delete ( self ) -> None : \"\"\"Delete an element.\"\"\" self . state = ElementState . DELETED self . closed = datetime . now () skip ( self ) \u00b6 Skip an element. Source code in pynbox/model.py def skip ( self ) -> None : \"\"\"Skip an element.\"\"\" self . skips += 1 ElementState ( str , Enum ) \u00b6 Define the possible element states. Source code in pynbox/model.py class ElementState ( str , Enum ): \"\"\"Define the possible element states.\"\"\" OPEN = \"open\" CLOSED = \"closed\" DELETED = \"deleted\" ElementType ( BaseModel ) pydantic-model \u00b6 Define the configuration attributes of the element types. Source code in pynbox/model.py class ElementType ( BaseModel ): \"\"\"Define the configuration attributes of the element types.\"\"\" name : str regexp : str priority : int = 3 services \u00b6 Define all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose. parse ( config , text ) \u00b6 Extract Elements from a text. Parameters: Name Type Description Default config Config pynbox configuration instance. required text str To process. required Returns: Type Description List[pynbox.model.Element] List of extracted Elements. Source code in pynbox/services.py def parse ( config : Config , text : str ) -> List [ Element ]: \"\"\"Extract Elements from a text. Args: config: pynbox configuration instance. text: To process. Returns: List of extracted Elements. \"\"\" elements : List [ Element ] = [] element = None type_regexps = { type_ . name : re . compile ( rf \"^ { type_ . regexp } ?(.*)\" , re . IGNORECASE ) for type_ in config . types } priority_regexp = re . compile ( r \"\\s([h])(?:\\s|$)\" , re . IGNORECASE ) log . debug ( \"Parsing elements\" ) for line in text . splitlines (): for type_ , regexp in type_regexps . items (): match = regexp . match ( line ) if match : elements = _register_element ( element , elements ) element = Element ( type_ = type_ , description = match . groups ()[ 0 ]) if priority_regexp . search ( line ): element . description = priority_regexp . sub ( \"\" , element . description ) element . priority = 5 break else : if element is None : raise ParseError ( f \"No element to append the body of line { line } \" ) if element . body is None : element . body = f \" { line } \" else : element . body += f \" \\n { line } \" elements = _register_element ( element , elements ) return elements parse_file ( config , repo , file_path ) \u00b6 Parse the elements from a file. Parameters: Name Type Description Default config Config pynbox configuration instance. required repo Repository repository to store the elements required file_path str Path to file to parse. required Source code in pynbox/services.py def parse_file ( config : Config , repo : Repository , file_path : str ) -> None : \"\"\"Parse the elements from a file. Args: config: pynbox configuration instance. repo: repository to store the elements file_path: Path to file to parse. \"\"\" with open ( file_path , \"r\" , encoding = \"utf-8\" ) as file_descriptor : elements = parse ( config , file_descriptor . read ()) for element in elements : repo . add ( element ) repo . commit () with open ( file_path , \"w\" , encoding = \"utf-8\" ) as file_descriptor : file_descriptor . write ( \"\" ) version \u00b6 Utilities to retrieve the information of the program version. version_info () \u00b6 Display the version of the program, python and the platform. Source code in pynbox/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"pynbox version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ()) views \u00b6 Define the views of the program. get_elements ( repo , config , type_ = None , newest = False ) \u00b6 Fetch and order the elements to process. Parameters: Name Type Description Default repo Repository Repository where the elements live. required type_ Optional[str] type of element to process. None newest bool Whether to show newest items first False Returns: Type Description List[pynbox.model.Element] Ordered list of elements to process. Source code in pynbox/views.py def get_elements ( repo : Repository , config : Config , type_ : Optional [ str ] = None , newest : bool = False ) -> List [ Element ]: \"\"\"Fetch and order the elements to process. Args: repo: Repository where the elements live. type_: type of element to process. newest: Whether to show newest items first Returns: Ordered list of elements to process. \"\"\" if type_ is None : types = [ type_ . name for type_ in config . types ] else : types = [ type_ ] elements = [] for element_type in types : with suppress ( EntityNotFoundError ): new_elements = repo . search ( { \"state\" : \"open\" , \"type_\" : element_type }, Element ) if newest : elements . extend ( sorted ( new_elements , key = operator . attrgetter ( \"created\" ), reverse = True ), ) else : elements . extend ( new_elements ) return elements status ( repo , config ) \u00b6 Get the number of open elements per type. Parameters: Name Type Description Default repo Repository Repository where the elements live. required type_ type of element to process. required Returns: Type Description Dict[str, int] Number of open tasks per type Source code in pynbox/views.py def status ( repo : Repository , config : Config ) -> Dict [ str , int ]: \"\"\"Get the number of open elements per type. Args: repo: Repository where the elements live. type_: type of element to process. Returns: Number of open tasks per type \"\"\" element_status = {} for type_ in config . types : with suppress ( EntityNotFoundError ): elements = len ( repo . search ({ \"state\" : \"open\" , \"type_\" : type_ . name }, Element )) if elements > 0 : element_status [ type_ . name ] = elements return element_status","title":"Reference"},{"location":"reference/#pynbox","text":"Task management inbox tool.","title":"pynbox"},{"location":"reference/#pynbox.config","text":"Define the configuration of the main program.","title":"config"},{"location":"reference/#pynbox.config.Config","text":"Configure the frontend. Source code in pynbox/config.py class Config ( GoodConf ): # type: ignore \"\"\"Configure the frontend.\"\"\" # URL specifying the connection to the database. For example: # * tinydb: tinydb:////home/user/database.tinydb # * sqlite: sqlite:////home/user/mydb.sqlite # * mysql: mysql://scott:tiger@localhost/mydatabase database_url : str = \"tinydb://~/.local/share/pynbox/database.json\" # Maximum time to process an element. A warning will be shown if it takes you # longer. max_time : int = 120 # List of element types. Each element can define: # * regexp: regular expression that identifies it # * priority: type priority, by default 3. types : List [ ElementType ] = [] log_level : LogLevel = LogLevel . INFO class Config : \"\"\"Define the default files to check.\"\"\" default_files = [ os . path . expanduser ( \"~/.local/share/pynbox/config.yaml\" ), \"config.yaml\" , ]","title":"Config"},{"location":"reference/#pynbox.config.Config.Config","text":"Define the default files to check. Source code in pynbox/config.py class Config : \"\"\"Define the default files to check.\"\"\" default_files = [ os . path . expanduser ( \"~/.local/share/pynbox/config.yaml\" ), \"config.yaml\" , ]","title":"Config"},{"location":"reference/#pynbox.config.LogLevel","text":"Define the possible log levels. Source code in pynbox/config.py class LogLevel ( str , Enum ): \"\"\"Define the possible log levels.\"\"\" DEBUG = \"debug\" INFO = \"info\" WARNING = \"warning\" ERROR = \"error\"","title":"LogLevel"},{"location":"reference/#pynbox.entrypoints","text":"Define the different ways to expose the program functionality. Functions load_logger: Configure the Logging logger.","title":"entrypoints"},{"location":"reference/#pynbox.entrypoints.get_repo","text":"Configure the repository. Source code in pynbox/entrypoints/__init__.py def get_repo ( config : \"Config\" ) -> Repository : \"\"\"Configure the repository.\"\"\" log . debug ( \"Initializing repository\" ) repo = load_repository ( database_url = config . database_url , search_exception = False ) return repo","title":"get_repo()"},{"location":"reference/#pynbox.entrypoints.load_config","text":"Load the configuration from the file. Source code in pynbox/entrypoints/__init__.py def load_config ( config_path : str ) -> Config : \"\"\"Load the configuration from the file.\"\"\" log . debug ( f \"Loading the configuration from file { config_path } \" ) config = Config () try : config . load ( os . path . expanduser ( config_path )) except ParserError as error : log . error ( f \"Configuration Error: { str ( error ) } \" ) sys . exit ( 1 ) return config","title":"load_config()"},{"location":"reference/#pynbox.entrypoints.load_logger","text":"Configure the Logging logger. Parameters: Name Type Description Default verbose bool Set the logging level to Debug. False Source code in pynbox/entrypoints/__init__.py def load_logger ( verbose : bool = False ) -> None : # pragma no cover \"\"\"Configure the Logging logger. Args: verbose: Set the logging level to Debug. \"\"\" logging . addLevelName ( logging . INFO , \"[ \\033 [36m+ \\033 [0m]\" ) logging . addLevelName ( logging . ERROR , \"[ \\033 [31m+ \\033 [0m]\" ) logging . addLevelName ( logging . DEBUG , \"[ \\033 [32m+ \\033 [0m]\" ) logging . addLevelName ( logging . WARNING , \"[ \\033 [33m+ \\033 [0m]\" ) if verbose : logging . basicConfig ( stream = sys . stderr , level = logging . DEBUG , format = \" %(levelname)s %(message)s \" ) else : logging . basicConfig ( stream = sys . stderr , level = logging . INFO , format = \" %(levelname)s %(message)s \" )","title":"load_logger()"},{"location":"reference/#pynbox.entrypoints.cli","text":"Define the command line interface.","title":"cli"},{"location":"reference/#pynbox.exceptions","text":"Define the program exceptions.","title":"exceptions"},{"location":"reference/#pynbox.exceptions.ParseError","text":"Gather the exceptions when parsing markup text. Source code in pynbox/exceptions.py class ParseError ( Exception ): \"\"\"Gather the exceptions when parsing markup text.\"\"\"","title":"ParseError"},{"location":"reference/#pynbox.model","text":"Define the program models.","title":"model"},{"location":"reference/#pynbox.model.Element","text":"Define the element model. Source code in pynbox/model.py class Element ( Entity ): \"\"\"Define the element model.\"\"\" type_ : str description : str body : Optional [ str ] = None priority : int = 3 skips : int = 0 state : ElementState = ElementState . OPEN created : datetime = Field ( default_factory = datetime . now ) closed : Optional [ datetime ] = None def close ( self ) -> None : \"\"\"Close an element.\"\"\" self . state = ElementState . CLOSED self . closed = datetime . now () def delete ( self ) -> None : \"\"\"Delete an element.\"\"\" self . state = ElementState . DELETED self . closed = datetime . now () def skip ( self ) -> None : \"\"\"Skip an element.\"\"\" self . skips += 1","title":"Element"},{"location":"reference/#pynbox.model.Element.close","text":"Close an element. Source code in pynbox/model.py def close ( self ) -> None : \"\"\"Close an element.\"\"\" self . state = ElementState . CLOSED self . closed = datetime . now ()","title":"close()"},{"location":"reference/#pynbox.model.Element.delete","text":"Delete an element. Source code in pynbox/model.py def delete ( self ) -> None : \"\"\"Delete an element.\"\"\" self . state = ElementState . DELETED self . closed = datetime . now ()","title":"delete()"},{"location":"reference/#pynbox.model.Element.skip","text":"Skip an element. Source code in pynbox/model.py def skip ( self ) -> None : \"\"\"Skip an element.\"\"\" self . skips += 1","title":"skip()"},{"location":"reference/#pynbox.model.ElementState","text":"Define the possible element states. Source code in pynbox/model.py class ElementState ( str , Enum ): \"\"\"Define the possible element states.\"\"\" OPEN = \"open\" CLOSED = \"closed\" DELETED = \"deleted\"","title":"ElementState"},{"location":"reference/#pynbox.model.ElementType","text":"Define the configuration attributes of the element types. Source code in pynbox/model.py class ElementType ( BaseModel ): \"\"\"Define the configuration attributes of the element types.\"\"\" name : str regexp : str priority : int = 3","title":"ElementType"},{"location":"reference/#pynbox.services","text":"Define all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose.","title":"services"},{"location":"reference/#pynbox.services.parse","text":"Extract Elements from a text. Parameters: Name Type Description Default config Config pynbox configuration instance. required text str To process. required Returns: Type Description List[pynbox.model.Element] List of extracted Elements. Source code in pynbox/services.py def parse ( config : Config , text : str ) -> List [ Element ]: \"\"\"Extract Elements from a text. Args: config: pynbox configuration instance. text: To process. Returns: List of extracted Elements. \"\"\" elements : List [ Element ] = [] element = None type_regexps = { type_ . name : re . compile ( rf \"^ { type_ . regexp } ?(.*)\" , re . IGNORECASE ) for type_ in config . types } priority_regexp = re . compile ( r \"\\s([h])(?:\\s|$)\" , re . IGNORECASE ) log . debug ( \"Parsing elements\" ) for line in text . splitlines (): for type_ , regexp in type_regexps . items (): match = regexp . match ( line ) if match : elements = _register_element ( element , elements ) element = Element ( type_ = type_ , description = match . groups ()[ 0 ]) if priority_regexp . search ( line ): element . description = priority_regexp . sub ( \"\" , element . description ) element . priority = 5 break else : if element is None : raise ParseError ( f \"No element to append the body of line { line } \" ) if element . body is None : element . body = f \" { line } \" else : element . body += f \" \\n { line } \" elements = _register_element ( element , elements ) return elements","title":"parse()"},{"location":"reference/#pynbox.services.parse_file","text":"Parse the elements from a file. Parameters: Name Type Description Default config Config pynbox configuration instance. required repo Repository repository to store the elements required file_path str Path to file to parse. required Source code in pynbox/services.py def parse_file ( config : Config , repo : Repository , file_path : str ) -> None : \"\"\"Parse the elements from a file. Args: config: pynbox configuration instance. repo: repository to store the elements file_path: Path to file to parse. \"\"\" with open ( file_path , \"r\" , encoding = \"utf-8\" ) as file_descriptor : elements = parse ( config , file_descriptor . read ()) for element in elements : repo . add ( element ) repo . commit () with open ( file_path , \"w\" , encoding = \"utf-8\" ) as file_descriptor : file_descriptor . write ( \"\" )","title":"parse_file()"},{"location":"reference/#pynbox.version","text":"Utilities to retrieve the information of the program version.","title":"version"},{"location":"reference/#pynbox.version.version_info","text":"Display the version of the program, python and the platform. Source code in pynbox/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"pynbox version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"version_info()"},{"location":"reference/#pynbox.views","text":"Define the views of the program.","title":"views"},{"location":"reference/#pynbox.views.get_elements","text":"Fetch and order the elements to process. Parameters: Name Type Description Default repo Repository Repository where the elements live. required type_ Optional[str] type of element to process. None newest bool Whether to show newest items first False Returns: Type Description List[pynbox.model.Element] Ordered list of elements to process. Source code in pynbox/views.py def get_elements ( repo : Repository , config : Config , type_ : Optional [ str ] = None , newest : bool = False ) -> List [ Element ]: \"\"\"Fetch and order the elements to process. Args: repo: Repository where the elements live. type_: type of element to process. newest: Whether to show newest items first Returns: Ordered list of elements to process. \"\"\" if type_ is None : types = [ type_ . name for type_ in config . types ] else : types = [ type_ ] elements = [] for element_type in types : with suppress ( EntityNotFoundError ): new_elements = repo . search ( { \"state\" : \"open\" , \"type_\" : element_type }, Element ) if newest : elements . extend ( sorted ( new_elements , key = operator . attrgetter ( \"created\" ), reverse = True ), ) else : elements . extend ( new_elements ) return elements","title":"get_elements()"},{"location":"reference/#pynbox.views.status","text":"Get the number of open elements per type. Parameters: Name Type Description Default repo Repository Repository where the elements live. required type_ type of element to process. required Returns: Type Description Dict[str, int] Number of open tasks per type Source code in pynbox/views.py def status ( repo : Repository , config : Config ) -> Dict [ str , int ]: \"\"\"Get the number of open elements per type. Args: repo: Repository where the elements live. type_: type of element to process. Returns: Number of open tasks per type \"\"\" element_status = {} for type_ in config . types : with suppress ( EntityNotFoundError ): elements = len ( repo . search ({ \"state\" : \"open\" , \"type_\" : type_ . name }, Element )) if elements > 0 : element_status [ type_ . name ] = elements return element_status","title":"status()"},{"location":"adr/001-high_level_problem_analysis/","text":"Status \u00b6 Accepted Context \u00b6 I've been using a markdown file to annotate all the elements of my inbox for later processing. The file was available both by computer and mobile phone and synced using Syncthing . The inbox elements are of different types: events, tasks, ideas, media suggestions (movies, tv shows, books or music). The problem is that I'm not able to keep the pace to process the elements and the file is increasingly growing. The goal is to have a piece of software that would help in inbox management by: Prioritizing a type of element over the others. Giving stats on the inbox status. Giving feedback on the inbox processing process. Making the insertion of new elements as effortless as possible. Proposals \u00b6 On the Android side, we can define a markup syntax where the user adds new items through an editor, such as Markor. That file gets synced to the desktop host through Syncthing. On the desktop side, we can have a command line client that: Processes the Android markup file to ingest the new elements. Has a REPL and TUI interfaces to add new elements. Has a REPL interface to process the existing inbox, which allows the user to select the order of the elements or a subset of them to process. It will monitor the inbox processing to detect improvable behaviours. And will give the user an idea of the state of the inbox. I've done a super quick search to see if there is anything there in the wild that fulfills the user case, but found none. If you know of a program that might work, please contact me . Decision \u00b6 Implement the proposed solution. Consequences \u00b6","title":"Status"},{"location":"adr/001-high_level_problem_analysis/#status","text":"Accepted","title":"Status"},{"location":"adr/001-high_level_problem_analysis/#context","text":"I've been using a markdown file to annotate all the elements of my inbox for later processing. The file was available both by computer and mobile phone and synced using Syncthing . The inbox elements are of different types: events, tasks, ideas, media suggestions (movies, tv shows, books or music). The problem is that I'm not able to keep the pace to process the elements and the file is increasingly growing. The goal is to have a piece of software that would help in inbox management by: Prioritizing a type of element over the others. Giving stats on the inbox status. Giving feedback on the inbox processing process. Making the insertion of new elements as effortless as possible.","title":"Context"},{"location":"adr/001-high_level_problem_analysis/#proposals","text":"On the Android side, we can define a markup syntax where the user adds new items through an editor, such as Markor. That file gets synced to the desktop host through Syncthing. On the desktop side, we can have a command line client that: Processes the Android markup file to ingest the new elements. Has a REPL and TUI interfaces to add new elements. Has a REPL interface to process the existing inbox, which allows the user to select the order of the elements or a subset of them to process. It will monitor the inbox processing to detect improvable behaviours. And will give the user an idea of the state of the inbox. I've done a super quick search to see if there is anything there in the wild that fulfills the user case, but found none. If you know of a program that might work, please contact me .","title":"Proposals"},{"location":"adr/001-high_level_problem_analysis/#decision","text":"Implement the proposed solution.","title":"Decision"},{"location":"adr/001-high_level_problem_analysis/#consequences","text":"","title":"Consequences"},{"location":"adr/002-initial_program_design/","text":"Status \u00b6 Accepted Context \u00b6 We need to define the architecture of the program to fulfill the goals of 001 . Proposals \u00b6 Storage \u00b6 For the storage we can use two approaches: Use the markup file that is synced between the mobile and the desktop. Use an external storage, and use the markup file just as a transport of data from the mobile. The first option is juicy as the code to interact with the storage would be simpler and with less dependencies. We need to write the parser anyway to get the data from the file. The side effects are that We would need to prevent the collisions between a mobile update and the data processed by the desktop client. For example, imagine that you've made some changes in the mobile, but they're not yet synced, you run the inbox processing tool and clear some, before the program has any chance to save the state, the mobile syncs the file. You'll have some changes in memory, and some non imported changes in the file. When the inbox grows, you can have performance issues. Having an external optimized storage will always be faster. There is no concept of temporal state: You'll only have the last picture of the inbox, not the progression, which could be interesting to show as part of the inbox statistics. Inputs \u00b6 There are two kind of sources: mobile and desktop. Mobile \u00b6 The mobile user will create a markup file that follows 003 . That file gets synced with Syncthing to the desktop, which extracts the data from it, ingests it in the storage solution and then cleans it. Desktop \u00b6 Addition of elements \u00b6 The desktop user will create elements directly in the storage solution. It can do it through: TUI command line arguments. REPL interface. Using the desktop editor. The TUI is useful to allow interaction between programs. We could accept an argument that uses the same markup as with the mobile device. The problem is that the editing features of the terminal are limited. The REPL interface could be a step forward in terms of usability from the TUI, with autocompletion, but it will still lack the editing features of a desktop editor. The editor is the quickest way to write in the desktop, but it will lack the domain specific features, such as autocompletion of the element types. Inbox processing \u00b6 The user is presented one element at a time selected from a prioritized list of elements. For each of them it can: Do the element. Postpone it. The first will mark the element as done, and won't appear in future inbox processing sessions. Postponing it will make the item show at the next session. The element prioritization is done by: Element category type: Each category will have a priority. Element creation date: Ordered by oldest first. It will measure the time spent between each element, and if it surpasses a defined amount, it will warn the user, so it is aware of it and can act accordingly. Once the inbox processing session is done, it will show the inbox stats. As a first approximation, it will show a measure of the done elements compared with how many are left. We'll use a REPL interface built with questionary , as it's the quickest library to build simple REPL, and is based in Prompt toolkit , which will give us more flexibility if we need more complex features. Decision \u00b6 For the storage we'll use Pydantic models managed by Repository-orm . We'll start with the TUI and launching the editor as input methods for the desktop, and a file following the markup language for mobile devices. Then we'll develop the inbox processing REPL. Consequences \u00b6","title":"002: Initial program design"},{"location":"adr/002-initial_program_design/#status","text":"Accepted","title":"Status"},{"location":"adr/002-initial_program_design/#context","text":"We need to define the architecture of the program to fulfill the goals of 001 .","title":"Context"},{"location":"adr/002-initial_program_design/#proposals","text":"","title":"Proposals"},{"location":"adr/002-initial_program_design/#storage","text":"For the storage we can use two approaches: Use the markup file that is synced between the mobile and the desktop. Use an external storage, and use the markup file just as a transport of data from the mobile. The first option is juicy as the code to interact with the storage would be simpler and with less dependencies. We need to write the parser anyway to get the data from the file. The side effects are that We would need to prevent the collisions between a mobile update and the data processed by the desktop client. For example, imagine that you've made some changes in the mobile, but they're not yet synced, you run the inbox processing tool and clear some, before the program has any chance to save the state, the mobile syncs the file. You'll have some changes in memory, and some non imported changes in the file. When the inbox grows, you can have performance issues. Having an external optimized storage will always be faster. There is no concept of temporal state: You'll only have the last picture of the inbox, not the progression, which could be interesting to show as part of the inbox statistics.","title":"Storage"},{"location":"adr/002-initial_program_design/#inputs","text":"There are two kind of sources: mobile and desktop.","title":"Inputs"},{"location":"adr/002-initial_program_design/#mobile","text":"The mobile user will create a markup file that follows 003 . That file gets synced with Syncthing to the desktop, which extracts the data from it, ingests it in the storage solution and then cleans it.","title":"Mobile"},{"location":"adr/002-initial_program_design/#desktop","text":"","title":"Desktop"},{"location":"adr/002-initial_program_design/#addition-of-elements","text":"The desktop user will create elements directly in the storage solution. It can do it through: TUI command line arguments. REPL interface. Using the desktop editor. The TUI is useful to allow interaction between programs. We could accept an argument that uses the same markup as with the mobile device. The problem is that the editing features of the terminal are limited. The REPL interface could be a step forward in terms of usability from the TUI, with autocompletion, but it will still lack the editing features of a desktop editor. The editor is the quickest way to write in the desktop, but it will lack the domain specific features, such as autocompletion of the element types.","title":"Addition of elements"},{"location":"adr/002-initial_program_design/#inbox-processing","text":"The user is presented one element at a time selected from a prioritized list of elements. For each of them it can: Do the element. Postpone it. The first will mark the element as done, and won't appear in future inbox processing sessions. Postponing it will make the item show at the next session. The element prioritization is done by: Element category type: Each category will have a priority. Element creation date: Ordered by oldest first. It will measure the time spent between each element, and if it surpasses a defined amount, it will warn the user, so it is aware of it and can act accordingly. Once the inbox processing session is done, it will show the inbox stats. As a first approximation, it will show a measure of the done elements compared with how many are left. We'll use a REPL interface built with questionary , as it's the quickest library to build simple REPL, and is based in Prompt toolkit , which will give us more flexibility if we need more complex features.","title":"Inbox processing"},{"location":"adr/002-initial_program_design/#decision","text":"For the storage we'll use Pydantic models managed by Repository-orm . We'll start with the TUI and launching the editor as input methods for the desktop, and a file following the markup language for mobile devices. Then we'll develop the inbox processing REPL.","title":"Decision"},{"location":"adr/002-initial_program_design/#consequences","text":"","title":"Consequences"},{"location":"adr/003-markup_definition/","text":"Status \u00b6 Draft Context \u00b6 We need to define a markup language that allows the introduction of new elements through a mobile device as effortlessly as possible. The information to extract from each element is: Description. Body Element type. Proposals \u00b6 The format of each element is: {{ type_identifier }} {{ description }} {{ body }} Where: type_identifier : Is a case insensitive string of the fewest letters as possible, that identifies the type of the element. It can be for example T. for a task, or i. for an idea. description : A short sentence that defines the element body : An optional group of paragraphs with more information of the element. For example: T. buy groceries * milk * tofu i. pynbox report could show progress bars for each element type Decision \u00b6 Follow the only proposed language Consequences \u00b6 We'd need to write the parser.","title":"003: Markup Definition"},{"location":"adr/003-markup_definition/#status","text":"Draft","title":"Status"},{"location":"adr/003-markup_definition/#context","text":"We need to define a markup language that allows the introduction of new elements through a mobile device as effortlessly as possible. The information to extract from each element is: Description. Body Element type.","title":"Context"},{"location":"adr/003-markup_definition/#proposals","text":"The format of each element is: {{ type_identifier }} {{ description }} {{ body }} Where: type_identifier : Is a case insensitive string of the fewest letters as possible, that identifies the type of the element. It can be for example T. for a task, or i. for an idea. description : A short sentence that defines the element body : An optional group of paragraphs with more information of the element. For example: T. buy groceries * milk * tofu i. pynbox report could show progress bars for each element type","title":"Proposals"},{"location":"adr/003-markup_definition/#decision","text":"Follow the only proposed language","title":"Decision"},{"location":"adr/003-markup_definition/#consequences","text":"We'd need to write the parser.","title":"Consequences"},{"location":"adr/00X-inbox_processing_enhacements/","text":"Improve the inbox stats","title":"00X inbox processing enhacements"},{"location":"adr/adr/","text":"ADR are short text documents that captures an important architectural decision made along with its context and consequences. graph TD 001[001: High level analysis] 002[002: Initial Program design] 003[003: Markup Definition] 001 -- Extended --> 002 002 -- Extended --> 003 click 001 \"https://lyz-code.github.io/pynbox/adr/001-high_level_problem_analysis\" _blank click 002 \"https://lyz-code.github.io/pynbox/adr/002-initial_program_design\" _blank click 002 \"https://lyz-code.github.io/pynbox/adr/003-markup_definition\" _blank 001:::accepted 002:::accepted 003:::accepted classDef draft fill:#CDBFEA; classDef proposed fill:#B1CCE8; classDef accepted fill:#B1E8BA; classDef rejected fill:#E8B1B1; classDef deprecated fill:#E8B1B1; classDef superseeded fill:#E8E5B1;","title":"Architecture Decision Records"}]}